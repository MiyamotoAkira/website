---
title: Into Adventure - Part 3 - State
date: 2015-11-7 22:00:00
---

### The difference maker

In his 2013 presentation at NDC London[1], Robert C. Martin (Uncle Bob), talked about some different types of programming paradigms. Well, the three major ones: Procedural, Object Oriented and Functional. On it he said that what makes Functional different from the others is Immutability. I have since think about that, and I believe to agree with him. Everything that I am talking in this series, which tend to be consider functional style, is present on the other paradigms.

Controlling side effects.

### A case of immutability

Let's look at some code:

{% highlight java %}

// Java
List<Integer> list = new ArrayList<Integer>();
list.add(5);
list.add(4);

{% endhighlight %}

The above code creates a list of Integer objects and then adds two values to the list.

Let's going to try to do the same on a FP language:

{% highlight clojure %}

// Clojure
(defn list-changer []
  (let [first []
       second (conj first 4 5)]
       (println first)
       (println second)))

{% endhighlight %}

The *first []* command creates an empty array binded to the key first. The line *second (conj first 4 5)* creates a new array which is the combination of the one that is binded to **first** and the values 4 and 5 (there are some optimizations done by Clojure, if you want to investigate them). That means that the array that is identified by **first** remains unchanged and we have a new array identified by **second**.

If we tried to do something like:

{% highlight clojure %}

// Clojure
(defn list-changer []
  (let [first []
       first (conj first 4 5)]
       (println first)
       (println first)))

{% endhighlight %}

Then we would remember that what we are doing is binding, not assignment. The empty array that was identified by **first** does still exist, somewhere. There is still a new array created. The old one, if is not identified by anything else (and therefore not used) will be taken care at some point by the GC.

We have two ways to confirm that this is the case.

First, getting the array passed as a parameter to the function:

{% highlight clojure %}

// Clojure
(defn list-changer2' [first]
  (let [first  (conj first 4 5)]
       (println first)))

{% endhighlight %}

If you declare an empty array somewhere, and pass it as the parameter of the function, inside the function you will print "4 5" as they are the members of array identified by first. But outside of the function the array will be empty.

The same code on Java will modify the outside list.

The other simple example to verify this is:

{% highlight Clojure %}

// Clojure
(defn list-changer3 []
  (let [first [1 2 3]
        second first
        second (conj second 4 5)]
       (println first)
       (println second)))

{% endhighlight %}

**first** has values "1 2 3", all the way through. **second** will have values "1 2 3 4 5"

### What makes immutability special?

If you have not programmed before on a FP language this is a question that you will make.

Predictability of functions. If there are no side effects, and the function result only on the parameters passed you can know exactly the results of the function.

Testability and formal verification are much easier on a FP language than on an OO or Procedural language.

Concurrency becomes easier. There are no locks that need to be applied to your code. There will be no values changing midway through the execution that are not controlled. Let me point here that if you are accesing an external resource, like a database, locks could still be needed.


### Conclusions?

Go Back to [Into Adventure Intro]({% post_url 2015-09-22-into-adventure-intro%})
